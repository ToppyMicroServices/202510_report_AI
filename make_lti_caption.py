#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
make_lti_caption.py
- Read LTI_summary_stats.csv and emit TeX macros for figure captions.

Default IO:
  input:  LTI_summary_stats.csv
  output: Tables/lti_caption_numbers.tex

Usage:
  python make_lti_caption.py
  python make_lti_caption.py --csv LTI_summary_stats.csv --out Tables/lti_caption_numbers.tex
"""

import argparse
import csv
from pathlib import Path
from decimal import Decimal, InvalidOperation
import sys


def fmt(x, digits=3, pct=False):
    """Format numbers with fixed digits using Decimal (no scientific notation).
    If pct=True, keep the numeric text but do not append a % here â€” TeX symbol is handled later.
    Returns empty string for None/empty inputs.
    """
    if x is None:
        return ""
    s = str(x).strip()
    if s == "":
        return ""
    try:
        d = Decimal(s)
    except (InvalidOperation, ValueError):
        # Not a number; return as-is (e.g., already formatted text)
        return s
    q = Decimal(1).scaleb(-digits)  # 10**(-digits)
    return f"{d.quantize(q)}"


def main():
    ap = argparse.ArgumentParser(description="Generate TeX macros for LTI caption from CSV")
    ap.add_argument("--csv", default="LTI_summary_stats.csv", help="Input CSV path")
    ap.add_argument("--out", default="Tables/lti_caption_numbers.tex", help="Output TeX macro file")
    ap.add_argument("--digits-r", type=int, default=3, help="Digits for correlations")
    ap.add_argument("--digits-slope", type=int, default=3, help="Digits for slopes")
    ap.add_argument("--digits-pct", type=int, default=1, help="Digits for percent diffs")
    ap.add_argument("--percent-sign", action="store_true", help="Append \\% to percent diff macros")
    ap.add_argument("--ci-brackets", default="[]", choices=["[]","()","{}"], help="Bracket style for CI macros")
    args = ap.parse_args()

    csv_path = Path(args.csv)
    if not csv_path.exists():
        raise SystemExit(f"Input CSV not found: {csv_path}")

    with csv_path.open(newline='', encoding='utf-8') as f:
        reader = csv.DictReader(f)
        row = None
        for r in reader:
            # pick the first non-empty row
            if any((str(v).strip() if v is not None else "") for v in r.values()):
                row = r
                break
        if row is None:
            raise SystemExit("Input CSV is empty")

    # Pull required fields with fallbacks
    def get(key, default=""):
        return row.get(key, default)

    def warn(msg):
        print(f"[warn] {msg}", file=sys.stderr)

    def is_num(s):
        try:
            Decimal(str(s))
            return True
        except Exception:
            return False

    # Correlations (NIS)
    pearson = fmt(get('pearson_NIS'), args.digits_r)
    pearson_lo = fmt(get('pearson_NIS_CI_lo'), args.digits_r)
    pearson_hi = fmt(get('pearson_NIS_CI_hi'), args.digits_r)
    spearman = fmt(get('spearman_NIS'), args.digits_r)

    # Slopes (NIS)
    ts_slope = fmt(get('TS_slope_NIS'), args.digits_slope)
    ts_slope_lo = fmt(get('TS_slope_NIS_CI_lo'), args.digits_slope)
    ts_slope_hi = fmt(get('TS_slope_NIS_CI_hi'), args.digits_slope)
    ols_slope = fmt(get('OLS_slope_NIS'), args.digits_slope)
    pct_diff_val = fmt(get('OLS_vs_TS_slope_diff_pct_NIS'), args.digits_pct, pct=True)

    # Optional (tail NIS_q), in case needed elsewhere
    pearson_q = fmt(get('pearson_NISq'), args.digits_r) if get('pearson_NISq') != '' else ''
    spearman_q = fmt(get('spearman_NISq'), args.digits_r) if get('spearman_NISq') != '' else ''
    ts_slope_q = fmt(get('TS_slope_NIS_q'), args.digits_slope) if get('TS_slope_NIS_q') != '' else ''

    # Build CI strings with chosen brackets
    L, R = ("[", "]") if args.ci_brackets == "[]" else (("(", ")") if args.ci_brackets == "()" else ("{", "}"))
    pearson_ci = f"{L}{pearson_lo}, {pearson_hi}{R}" if pearson_lo and pearson_hi else ""
    ts_slope_ci = f"{L}{ts_slope_lo}, {ts_slope_hi}{R}" if ts_slope_lo and ts_slope_hi else ""

    # Sanity checks (non-fatal)
    if pearson and is_num(pearson):
        try:
            v = float(pearson)
            if not (-1.0 <= v <= 1.0):
                warn(f"pearson_NIS={pearson} is outside [-1,1]")
        except Exception:
            pass

    out_path = Path(args.out)
    if out_path.parent and not out_path.parent.exists():
        out_path.parent.mkdir(parents=True, exist_ok=True)

    lines = []
    lines.append("% Auto-generated by make_lti_caption.py; do not edit manually.")
    lines.append("% Source: " + str(csv_path.resolve()))

    def emit(name: str, val: str) -> None:
        # Always define the macro, even if val is empty
        lines.append(f"\\newcommand{{\\{name}}}{{{val}}}")

    # Core correlations (always emit)
    emit("LTIPearsonNIS", pearson)
    emit("LTIPearsonNISLo", pearson_lo)
    emit("LTIPearsonNISHi", pearson_hi)
    emit("LTIPearsonNISCI", pearson_ci)  # may be empty
    emit("LTISpearmanNIS", spearman)

    # Slopes (always emit)
    emit("LTITSSlopeNIS", ts_slope)
    emit("LTITSSlopeNISLo", ts_slope_lo)
    emit("LTITSSlopeNISHi", ts_slope_hi)
    emit("LTITSSlopeNISCI", ts_slope_ci)  # may be empty
    emit("LTIOLSSlopeNIS", ols_slope)

    # Percent diff macro (always emit). If value exists and --percent-sign given, append \%.
    if pct_diff_val:
        pct_text = pct_diff_val + ("\\%" if args.percent_sign else "")
    else:
        pct_text = ""
    emit("LTIOLSTSDiffPctNIS", pct_text)

    # Optional q-variants (always emit, even if empty)
    emit("LTIPearsonNISq", pearson_q)
    emit("LTISpearmanNISq", spearman_q)
    emit("LTITSSlopeNISq", ts_slope_q)

    out_path.write_text("\n".join(lines) + "\n", encoding='utf-8')
    print(f"[ok] wrote TeX macros: {out_path}")
    print("[summary] ", {
        "pearson": pearson,
        "pearson_CI": pearson_ci,
        "spearman": spearman,
        "TS_slope": ts_slope,
        "TS_CI": ts_slope_ci,
        "OLS_slope": ols_slope,
        "OLS_vs_TS_diff_pct": (pct_diff_val + ("%" if args.percent_sign and pct_diff_val else ""))
    })


if __name__ == "__main__":
    main()
